<?xml version="1.0" encoding="UTF-8"?>
<table xmlns="http://query.yahooapis.com/v1/schema/table.xsd">
  <meta>
    <author>Vic Mortelmans</author>
    <description>The table contains the complete bible. Each passage is a record, identified by its citation reference.</description>
    <sampleQuery>select * from bible.bible where language='en' and bibleref='Luke 11:10' and tolerance='true'</sampleQuery>
    <documentationURL>http://docs.google.com/View?id=ddq89pzk_155t6rwmkhp</documentationURL>
  </meta>
  <bindings>
    <select produces="XML" itemPath="">
      <urls>
        <url></url>
      </urls>
      <inputs>
        <key id="language" type="xs:string" paramType="variable" required="false"/>
        <key id="edition" type="xs:string" paramType="variable" required="false"/>
        <key id="service" type="xs:string" paramType="variable" required="false"/>
        <key id="book" type="xs:string" paramType="variable" required="false"/>
        <key id="chapter" type="xs:integer" paramType="variable" required="false"/>
        <key id="passage" type="xs:integer" paramType="variable" required="false"/>
        <key id="bibleref" type="xs:string" paramType="variable" required="false"/>
        <key id="tolerance" type="xs:string" paramType="variable" required="false"/>
        <key id="chunksize" type="xs:integer" paramType="variable" required="false"/>
        <key id="chunk" type="xs:integer" paramType="variable" required="false"/>
      </inputs>
      <execute><![CDATA[ 
        String.prototype.trim = function() {
          // Strip leading and trailing white-space
          return this.replace(/^\s+|\s+$/g, "");
        }
      
        var debug = 1;
        if (!edition && !language) {
          language = "en";
        }
        if (!tolerance) {
          tolerance = "false";
        }
        // parse the bible reference into a list of verse references
        var biblerefsxml;
        if (!bibleref) {
          if (!book && !chapter) {
            y.log('At least a book and a chapter number should be provided.');
            y.exit();
          }
          biblerefsxml = <biblerefs>
            <bibleref>
                <book>{book}</book>
                <chapter>{chapter}</chapter>
                <verse>{verse}</verse>
                <phrase/>
            </bibleref>
          </biblerefs>;
          bibleref = book + ' ' + chapter + ':' + verse;
        } else {
          var biblerefsquery = "use 'https://raw.githubusercontent.com/vicmortelmans/yql-tables/master/bible/bibleref.xml' as bible.bibleref;select * from bible.bibleref where bibleref='$bibleref' and tolerance='$tolerance'";
          biblerefsquery = biblerefsquery.replace("$bibleref",bibleref);
          biblerefsquery = biblerefsquery.replace("$tolerance",tolerance);
          biblerefsxml = y.query(biblerefsquery).results.biblerefs;
          if (biblerefsxml.length() == 0) {
            y.log('Invalid bible reference.');
            y.exit()
          }
        }
        debug && y.log("Bible references: ");
        debug && y.log(biblerefsxml);
        // get some localized info
        var localbiblerefsquery = "use 'https://raw.githubusercontent.com/vicmortelmans/yql-tables/master/bible/bibleref.xml' as bible.bibleref;select * from bible.bibleref where bibleref='$bibleref' and language='$language' and tolerance='$tolerance'";
        localbiblerefsquery = localbiblerefsquery.replace("$bibleref",bibleref);
        localbiblerefsquery = localbiblerefsquery.replace("$language",language);
        localbiblerefsquery = localbiblerefsquery.replace("$tolerance",tolerance);
        localbiblerefsxml = y.query(localbiblerefsquery).results.biblerefs;
        localbibleref = localbiblerefsxml.bibleref[0].localbook + ' ' + localbiblerefsxml.bibleref[0].chapterversereference;
        book = biblerefsxml.bibleref[0].book.toString();
        var booksquery = 'select book from xml where url="https://raw.githubusercontent.com/vicmortelmans/BibleConfiguration/master/books.xml" and book.input matches "(?i)$book"';
        booksquery = booksquery.replace("$book",book);
        var books = y.query(booksquery).results.books;
        if (books.book.length() < 1) {
            var error_message = '$book is not a bible book. Common bible book abbreviations : $supported';
            error_message = error_message.replace("$book",book);
            error_message = error_message.replace("$supported","http://biblewiki.net/books/index");
            y.log(error_message);
            y.exit();
        }
        book = books.book[0];
        debug && y.log(book);
        // get the configuration data for editions and services
        var editionsquery = 'select edition from xml where url="https://raw.githubusercontent.com/vicmortelmans/BibleConfiguration/master/editions.xml" and edition.language matches "(?i)$language"';
        editionsquery = editionsquery.replace("$language",language?language:'.*');
        var editionsxml = y.query(editionsquery).results.editions.edition;
        debug && y.log("Editions: ");
        debug && y.log(editionsxml);
        var priority = 0;
        var editionservices = [];
        for each (var editionxml in editionsxml) {
          for each (var servicexml in editionxml.code) {
            var editionservicepriority = priority++;
            if (edition && editionxml.(input == edition))
              editionservicepriority += 10;
            else if (editionxml.default_ == "true")
              editionservicepriority += 50;
            else if (service && servicexml.(input == service))
              editionservicepriority += 100;
            else if (servicexml.@default_ == "true")
              editionservicepriority += 500;
            else 
              editionservicepriority += 1000;
            editionservices.push({
              "edition": editionxml,
              "servicename": servicexml.input.text(),
              "priority": editionservicepriority
            });
            debug && y.log('Edition: ' + editionxml.input[0].text() + '; Service: ' + servicexml.input[0].text() + '; Priority: ' + editionservicepriority);
          }
        }
        editionservices.sort(function(a,b) {
          return a.priority - b.priority;
        });
        editionservice = editionservices.shift();
        y.log('Using: ');
        y.log(editionservice.edition.input[0].text());
        y.log(editionservice.servicename);
        if (editionservice.edition.copyright.text()) {
          y.log('Copyright: ');
          y.log(edition.copyright.text());
        }
        debug && y.log(editionservice);
        var queryoutput = new String();
        var output = new String();
        var versecount = 0;
        var remainingversesinpassage = 0;
        if (chunk && chunksize) {
          var versechunkstart = (chunk - 1) * chunksize + 1; 
          var versechunkend = chunk * chunksize;
        }
        var endverse;
        for each (var biblerefxml in biblerefsxml.*) {
          versecount++;
          if (!chunk || (versechunkstart <= versecount && versecount <= versechunkend)) {
            debug && y.log(biblerefxml);
            endverse = biblerefxml;
            while (1) {
              var url = new String();
              var finalquery = new String();
              if (!editionservice.service) {
                var servicesquery = 'select service from xml where url="https://raw.githubusercontent.com/vicmortelmans/BibleConfiguration/master/services.xml" and service.name matches "(?i)$service"';
                servicesquery = servicesquery.replace("$service",editionservice.service.input.text());
                var services = y.query(servicesquery).results.services;
                if (services.service.length() < 1) {
                    var error_message = 'Internal error';
                    y.log(error_message);
                    y.exit();
                }
                editionservice.service = services.service[0];
                debug && y.log(editionservice.service);
                var bookcode = book.code.(@service == editionservice.service.bookskey.text()).text();
                var editioncode = edition.code.(@service == editionservice.service.editionskey.text()).text();
              }
              for each (var step in editionservice.service.step) {
                if (step.@nr < editionservice.service.step.length()) { 
                  if (step.@yql.text() == "true") { // yql query
                    debug && y.log("YQL query");
                    var query = step.text();
                    query = query.replace(/\$book/g,bookcode);
                    query = query.replace(/\$edition/g,editioncode);
                    query = query.replace(/\$chapter/g,biblerefxml.chapter.text());
                    query = query.replace(/\$passage/g,biblerefxml.verse.text());
                    query = query.replace(/\$url/g,url);
                    var results = y.query(query).results;
                    url = results.a.@href.text();
                    debug && y.log(url);
                  } else { // rest call
                    debug && y.log("REST query");
                    var rest = step.text();
                    rest = rest.replace(/\$book/g,escape(bookcode));
                    rest = rest.replace(/\$edition/g,escape(editioncode));
                    rest = rest.replace(/\$chapter/g,escape(biblerefxml.chapter.text()));
                    rest = rest.replace(/\$passage/g,escape(biblerefxml.verse.text()));
                    rest = rest.replace(/\$url/g,escape(url));
                    url = rest;
                    debug && y.log(url);
                  }
                } else { // last step is always yql query
                    debug && y.log("Final YQL query");
                    finalquery = step.text();
                    finalquery = finalquery.replace(/\$book/g,bookcode);
                    finalquery = finalquery.replace(/\$edition/g,editioncode);
                    finalquery = finalquery.replace(/\$chapter/g,biblerefxml.chapter.text());
                    finalquery = finalquery.replace(/\$passage/g,biblerefxml.verse.text());
                    finalquery = finalquery.replace(/\$url/g,url);
                    debug && y.log(finalquery);
                }
              }
              queryoutput = stringListValue(y.query(finalquery).results);
              queryoutput = queryoutput.trim();
              if (queryoutput.length > 0) {
                break; // success
              } else {
                if (editionservices) {
                  editionservice = editionservices.shift();
                  y.log('Using: ');
                  y.log(editionservice.edition.input.text());
                  y.log(editionservice.service.input.text());
                  if (editionservice.edition.copyright.text()) {
                    y.log('Copyright: ');
                    y.log(edition.copyright.text());
                  }
                  debug && y.log(editionservice);
                } else {
                  y.log('No bible service found that produces any output. This is a severe error. Please report to info@gelovenleren.net.');
                  y.exit();
                }
              }
            } // while (1)  
            var verseIndication = queryoutput.match(/^[0-9]+/);
            if ( verseIndication && verseIndication[0] === biblerefxml.verse.text()) {
              queryoutput = queryoutput.replace(/^[0-9]+[.\s]*/,'');
            }
            debug && y.log(queryoutput);
            if (biblerefxml.phrase != '') {
              queryoutput = extractPhrase(queryoutput,biblerefxml.phrase.text());
            }
            debug && y.log(queryoutput);
            output += (queryoutput + ' ');
          }
        } // for each biblerefxml
        if (chunk && chunksize) {
          remainingversesinpassage = Math.max(0,versecount - versechunkend);
        }
        output = output.trim();
        output = output.replace(/\s+/g, ' ');
        var punctuation = output.match(/[.?!,:;]$/);
        if (!punctuation) {
          output += '.';
        }
        else if (punctuation[0].match(/[,:;]/)) {
          output = output.replace(/[,:;]$/,'.');
        }
        output = output.charAt(0).toUpperCase() + output.slice(1);
        if ( -1 != output.indexOf("’") && 
             -1 == output.substring(0,output.indexOf("’")).indexOf("‘") ) {
          output = '‘' + output;
        }
        if ( -1 != output.indexOf("‘") && 
             -1 == output.substring(output.lastIndexOf("‘"),output.length-1).indexOf("’") ) {
          output += '’';
        }
        response.object = <passage bibleref={localbibleref} remainingversesinpassage={remainingversesinpassage} remainingversesinchapter={endverse.remainingverses} book={endverse.book} chapter={endverse.chapter} endverse={endverse.verse} spoken={localbiblerefsxml.bibleref[0].spoken}>{output}</passage>;

        function stringValue(node) {
            var value = new String();
            if (node.hasSimpleContent()) {
                value = node.text();
            } else {
                for each (var c in node.children()) {
                    value += stringValue(c);
                }
            }
            return value;
        }

        function stringListValue(node) {
            var value = new String();
            if (node.hasSimpleContent()) {
                value = node.text();
            } else {
                for each (var c in node.children()) {
                    value += stringValue(c) + " ";
                }
            }
            return value;
        }

        function extractPhrase(passage,phrase) {
          phrasechar = phrase.replace('-','');
          var phrases = new Array();
          var remainingpassage = passage.trim();
          while (remainingpassage.length > 0) {
            y.log(remainingpassage.length);
            y.log(remainingpassage);
            var search = remainingpassage.search(/[.!?]["' ,]*\w|;|: *\W/); 
            /* /[.!?]["' ,]*[[A-Z]]|;/ */
            y.log(search);
            if (search < 0) {
              phrases.push(remainingpassage);
              remainingpassage = "";
            } else {
              phrases.push(remainingpassage.slice(0,search+2).trim());
              remainingpassage = remainingpassage.substr(search+1).trim();
            }
            debug && y.log(phrases[phrases.length-1]);
          }
          var index = "abcdefghijkl".indexOf(phrasechar);
          var i = 0;
          var result = new String();
          var before = phrase.match(/^-/);
          debug && y.log("before: " + before);
          var after = phrase.match(/-$/);
          debug && y.log("after: " + after);
          for each (var p in phrases) {
            var b;
            b = (i == index);
            b = b || (before && i < index);
            b = b || (after && i > index);
            debug && y.log(b);
            if (b) {
              result += (p + ' ');
            }
            i++;
          }
          return result;
        }

      ]]></execute>
      </select>
  </bindings>
</table>
